(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{395:function(a,s,t){"use strict";t.r(s);var e=t(42),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"后端配置记录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后端配置记录"}},[a._v("#")]),a._v(" 后端配置记录")]),a._v(" "),t("h2",{attrs:{id:"lxc-容器方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lxc-容器方案"}},[a._v("#")]),a._v(" LXC 容器方案")]),a._v(" "),t("h3",{attrs:{id:"为什么选择-lxc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么选择-lxc"}},[a._v("#")]),a._v(" 为什么选择 LXC？")]),a._v(" "),t("p",[a._v("无论是搭建镜像站，还是其他服务，首要的任务是实现功能，其次是保证稳定，有余力则追求美观。")]),a._v(" "),t("p",[a._v("因此，在单一 Linux 发行版上部署所有服务是十分不明智的做法。例如，激进的发行版提供更多、更新的软件包，而保守的发行版则具有更好的稳定性。此外，在保守发行版上编译安装新程序的做法则显得十分愚蠢——应尽可能选择通过发行版的官方仓库来部署服务，否则稳定性就是无稽之谈。容器级虚拟化就是用来调和两者矛盾的方案。")]),a._v(" "),t("p",[a._v("为此，我们选择了基于 LXC 的容器方案。LXC 在 2008 年诞生，目的是在共享主机内核的基础上，提供虚拟容器，每个容器运行一个完整的操作系统。与 Docker 相比，一个容器不必仅运行单一服务，因此可根据功能划分容器，便于管理；LXC 主机非常“干净”，除了提供 LXC 管理工具及网络外，无需参与任何具体的任务逻辑，因此具有更强的健壮性——尤其是这台服务器没有 IPMI、没有控制台，唯一的控制方式就是 SSH 时，主机的稳定性就更显得重要了。")]),a._v(" "),t("h3",{attrs:{id:"lxc-主机应该选用什么发行版"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lxc-主机应该选用什么发行版"}},[a._v("#")]),a._v(" LXC 主机应该选用什么发行版？")]),a._v(" "),t("p",[a._v("对于 LXC 主机而言，稳定是第一要素。RHEL/CentOS 7 虽然在稳定性方面广受赞誉，但 Linux 3.10 内核与 LXC 1.0 工具集则显得力不从心。理论上，你可以用低版本内核运行原本为高版本内核准备的发行版容器，但实际应用中会导致诸多的小问题，如容器无法开机、DNS 解析发生阻塞等。在经过初步尝试后，RHEL/CentOS 7 确实无法胜任 LXC 主机的角色，被首先排除。CentOS 8 的发布遥遥无期，不做考虑。")]),a._v(" "),t("p",[a._v("由于 LXC 主机要做的事情很简单，ArchLinux 或许可以保证稳定运行。但过于激进的发行版应放在最后考虑。")]),a._v(" "),t("p",[a._v("作为老牌 Linux 发行版，Debian 拥有不输 RHEL/CentOS 的稳定性，同时内核较新，是容器级虚拟化的理想选择。截至本文编写时（2019 年 5 月），稳定版对应了搭载 4.9 内核的 Debian 9，而搭载了 4.19 内核的 Debian 10 刚刚进入 RC 阶段，软件包版本已基本冻结。不要因为“非正式版”就将 Debian 10 排除在外，这条可能对于其他发行版适用，但 Debian 即使是 unstable 版本也有不输 Ubuntu 的稳定性。")]),a._v(" "),t("p",[a._v("由于 4.9 内核搭配高于 4.9 内核的发行版容器时仍会出现 DNS 解析阻塞问题，因此即使 Debian 10 正式发布还需要数月，我们仍然选择了 Debian 10。")]),a._v(" "),t("h3",{attrs:{id:"lxc-容器应该选用什么发行版"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lxc-容器应该选用什么发行版"}},[a._v("#")]),a._v(" LXC 容器应该选用什么发行版？")]),a._v(" "),t("p",[a._v("容器的发行版主要根据要实现的功能决定。例如，对于 HTTP 服务器，由于镜像站主要在内网运行，我们暂不关心 TLS 1.3，因此选择了 CentOS 7 发行版。同步程序以 Python 脚本、rsync 等为主，选择范围较广，考虑到 apt-mirror 工具，我们选择了与主机相同的 Debian 10 发行版。对于前端代码，我们选择了 ArchLinux，以便使用最新版的 nodejs 和 yarn 等工具。重复一遍，官方源的软件是最稳定的，其次是可靠的第三方源，而编译安装则是最愚蠢的行为——但 Docker 用户请忽略这句话。")]),a._v(" "),t("h3",{attrs:{id:"lxc-主机的主要配置过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lxc-主机的主要配置过程"}},[a._v("#")]),a._v(" LXC 主机的主要配置过程")]),a._v(" "),t("h4",{attrs:{id:"安装-debian-10"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装-debian-10"}},[a._v("#")]),a._v(" 安装 Debian 10")]),a._v(" "),t("h5",{attrs:{id:"获取镜像"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取镜像"}},[a._v("#")]),a._v(" 获取镜像")]),a._v(" "),t("p",[a._v("截至本文编写时（2019 年 5 月），Debian 10 尚未正式发行，因此 Debian 9 的镜像更易获取。虽然每周构建版本的 Debian 10 依然可用，但受限于下载速度，我们选择了先安装 Debian 9 再升级到 Debian 10 的做法。")]),a._v(" "),t("p",[a._v("注：不知出于何种原因，我们的虚拟机提供方仅愿意预装 CentOS 7——巧妇难为无米之炊。在仅有 SSH 的前提下，我们选择了对最开头 1GiB 的 boot 分区解除挂载，然后将预先制作好的磁盘镜像 dd 到硬盘开头的做法来更换操作系统。但出于方便读者的考虑，在下文的叙述中，仍假设可以直接从光盘安装 Debian。")]),a._v(" "),t("p",[a._v("将 Debian 的光盘插入服务器，进入安装界面。")]),a._v(" "),t("h5",{attrs:{id:"硬盘分区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#硬盘分区"}},[a._v("#")]),a._v(" 硬盘分区")]),a._v(" "),t("p",[a._v("对系统磁盘分区时，根据服务器是否支持 UEFI 启动，选择 GUID 分区表（GPT）或 MBR 分区表。")]),a._v(" "),t("p",[a._v("对于 GUID 分区表（GPT），首先创建一个 500 MB 左右的 EFI 系统分区（ESP），格式化为 FAT32（唯一被 UEFI 标准支持的文件系统），挂载到 "),t("code",[a._v("/boot/efi")]),a._v("。然后将剩余的空间全部分配给一个主分区，挂载到 "),t("code",[a._v("/")]),a._v("。")]),a._v(" "),t("p",[a._v("对于 MBR 分区表，则可选择将全部的空间分配给一个主分区（设为活动分区），挂载到 "),t("code",[a._v("/")]),a._v("。也可选择创建一个 500 MB 左右的主分区（设为活动分区），不格式化，然后将剩余的空间全部分配给一个主分区，挂载到 "),t("code",[a._v("/")]),a._v("（不是活动分区）。MBR 分区表的 "),t("code",[a._v("扩展分区")]),a._v(" "),t("code",[a._v("逻辑分区")]),a._v("的设计是极其糟糕的，因此只需要使用主分区即可。")]),a._v(" "),t("p",[a._v("注意，均不分配 SWAP 分区。SWAP 分区的优势是保证交换空间在存储设备上的连续性，以便加速访问。然而，对于固态硬盘而言，位置连续没有意义。即便是对于机械硬盘，由于 SWAP 文件一般是在分区基本为空的情况下创建的，只要不改变 SWAP 文件的大小——SWAP 分区本来就做不到这一点——也不会产生碎片。Ubuntu 从 18.04 桌面版开始，默认使用 SWAP 文件代替了 SWAP 分区。因此，在大多数场景下，应使用 SWAP 文件而不是 SWAP 分区。")]),a._v(" "),t("p",[a._v("对于数据磁盘，一律使用 GUID 分区表。牢记，好习惯是，在一台机器上最多只有一个磁盘是 MBR 分区表，即在服务器不支持 UEFI 启动时系统盘可选择 MBR。除了系统盘外的其他磁盘一律不要使用 MBR 分区表，否则无论是对引导还是分区管理都没有好处。")]),a._v(" "),t("h5",{attrs:{id:"组件选择"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件选择"}},[a._v("#")]),a._v(" 组件选择")]),a._v(" "),t("p",[a._v("不要选择桌面环境。LXC 主机的软件包应尽可能地少，软件包越少，系统越稳定，此外也有利于减少攻击面。记得选择 SSH Server，或者也可以等到后期再安装。")]),a._v(" "),t("h5",{attrs:{id:"安装-grub-引导器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装-grub-引导器"}},[a._v("#")]),a._v(" 安装 grub 引导器")]),a._v(" "),t("p",[a._v("Debian 安装程序会提示你该将 grub 安装至何处。对于 MBR 分区表，应将 Grub 安装在系统磁盘的活动分区上。（一个 MBR 磁盘上只能有一个或零个活动分区，且活动分区一定是主分区。）对于 GUID 分区表，将其安装在 "),t("code",[a._v("EFI 系统分区")]),a._v("（ESP）即可。")]),a._v(" "),t("h5",{attrs:{id:"升级到-debian-10"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#升级到-debian-10"}},[a._v("#")]),a._v(" 升级到 Debian 10")]),a._v(" "),t("p",[a._v("Debian 的大版本升级很简单，只要将 "),t("code",[a._v("/etc/apt/sources.list")]),a._v(" 中的发行版代号由 Debian 9 的 "),t("code",[a._v("stretch")]),a._v(" 替换为 Debian 10 的 "),t("code",[a._v("buster")]),a._v("，然后执行 "),t("code",[a._v("apt update && apt dist-upgrade")]),a._v(" 即可。中途要注意文件替换的问题，不要无脑 yes，以免配置文件被新版缺省配置文件覆盖。")]),a._v(" "),t("h5",{attrs:{id:"安装基本软件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装基本软件"}},[a._v("#")]),a._v(" 安装基本软件")]),a._v(" "),t("p",[a._v("安装以下基本软件。不再单独强调。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("apt")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("install")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("screen")]),a._v(" tmux "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("wget")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("nano")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("curl")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("sudo")]),a._v("\n")])])]),t("h4",{attrs:{id:"网络配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络配置"}},[a._v("#")]),a._v(" 网络配置")]),a._v(" "),t("h5",{attrs:{id:"更换网络管理器为-systemd-networkd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#更换网络管理器为-systemd-networkd"}},[a._v("#")]),a._v(" 更换网络管理器为 systemd-networkd")]),a._v(" "),t("p",[a._v("systemd-networkd 是主要适用于有线网络的网络管理器，与 NetworkManager 相比更简单，与传统的网络配置脚本相比更现代化。我们推荐在服务器上使用 systemd-networkd，以便为 LXC 容器提供更简单的网络设置。")]),a._v(" "),t("h6",{attrs:{id:"创建配置文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建配置文件"}},[a._v("#")]),a._v(" 创建配置文件")]),a._v(" "),t("p",[t("code",[a._v("/etc/systemd/network")]),a._v(" 是 systemd-networkd 的配置文件所在目录。创建一个 "),t("code",[a._v("10-wired.network")]),a._v(" 文件，内容为：")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Match]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Name")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("e*")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Network]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("DHCP")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("no")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Address")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("10.102.7.58/23")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Gateway")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("10.102.7.254")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("DNS")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("114.114.114.114")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Link]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("MTUBytes")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("1428")]),a._v("\n")])])]),t("p",[a._v("一目了然，无需多言。")]),a._v(" "),t("h6",{attrs:{id:"禁用-debian-默认的网络管理器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#禁用-debian-默认的网络管理器"}},[a._v("#")]),a._v(" 禁用 Debian 默认的网络管理器")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("mv")]),a._v(" /etc/network/interfaces /etc/network/interfaces.bak\nsystemctl stop networking\nsystemctl disable networking\n")])])]),t("p",[a._v("根据安装时选择的软件包不同，NetworkManager 可能也被安装。卸载之。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("apt")]),a._v(" remove network-manager\n")])])]),t("h6",{attrs:{id:"启动-systemd-networkd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#启动-systemd-networkd"}},[a._v("#")]),a._v(" 启动 systemd-networkd")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[a._v("systemctl start systemd-networkd\nsystemctl "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("enable")]),a._v(" systemd-networkd\n")])])]),t("h6",{attrs:{id:"重启系统以验证设置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重启系统以验证设置"}},[a._v("#")]),a._v(" 重启系统以验证设置")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("systemctl "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("reboot")]),a._v("\n")])])]),t("p",[a._v("注意，如果配置不正确，SSH 将无法连接。请确保有备用手段可以连接主机。")]),a._v(" "),t("p",[a._v("在极端情况下，可考虑手动为其分配 IP 地址使其重新联网。假设网络接口名称为 "),t("code",[a._v("ens192")]),a._v("，以下命令会相当有用。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("ip")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 查看 IP 地址")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("ip")]),a._v(" r "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 查看路由表")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("ip")]),a._v(" n "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 查看 ARP/NDP")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("ip")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("add")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("192.168")]),a._v(".0.2/24 dev ens192 "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 为 ens192 分配指定的静态 IP")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("ip")]),a._v(" r "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("add")]),a._v(" default via "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("192.168")]),a._v(".0.1 "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 指定默认路由")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("rm")]),a._v(" /etc/resolv.conf "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("echo")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"nameserver 8.8.8.8"')]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" /etc/resolv.conf "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#设置 DNS")]),a._v("\n")])])]),t("h6",{attrs:{id:"使用-systemd-resolved"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-systemd-resolved"}},[a._v("#")]),a._v(" 使用 systemd-resolved")]),a._v(" "),t("p",[a._v("使用与 systemd-networkd 配套的 systemd-resolved 以管理 DNS 地址。")]),a._v(" "),t("p",[a._v("根据 Debian 版本不同，可能需要手动安装 systemd-resolved 软件包，也可能已经内置在系统中。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("apt")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("install")]),a._v(" systemd-resolved\n")])])]),t("p",[a._v("删除 resolvconf 软件包。我们不使用它管理 DNS 地址。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("apt")]),a._v(" remove resolvconf\n")])])]),t("p",[a._v("注意，为了避免与后面使用的 dnsmasq 冲突，需要禁用 systemd-networkd 的 DNS 缓存功能。此外，由于众所周知的原因，不能强制使用 DNSSEC。")]),a._v(" "),t("p",[a._v("修改 "),t("code",[a._v("/etc/systemd/resolved.conf")]),a._v(" 文件，设置以下选项：")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Resolve]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Cache")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("no")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("DNSStubListener")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("no")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("DNSSEC")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("allow-downgrade")]),a._v("\n")])])]),t("p",[a._v("启动 systemd-resolved，并配置好 DNS。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("systemctl "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("enable")]),a._v(" systemd-resolved\nsystemctl start systemd-resolved\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("rm")]),a._v(" /etc/resolv.conf\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("ln")]),a._v(" -s /run/systemd/resolve/resolv.conf /etc/resolv.conf\n")])])]),t("h6",{attrs:{id:"为-lxc-提供网桥和-nat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为-lxc-提供网桥和-nat"}},[a._v("#")]),a._v(" 为 LXC 提供网桥和 NAT")]),a._v(" "),t("p",[a._v("创建 "),t("code",[a._v("20-lxc-bridge.netdev")]),a._v(" 文件，内容如下：")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[NetDev]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Name")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("lxc-bridge")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Kind")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("bridge")]),a._v("\n")])])]),t("p",[a._v("创建 "),t("code",[a._v("20-lxc-bridge.network")]),a._v("文件，内容如下：")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Match]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Name")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("lxc-bridge")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Network]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Address")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("192.168.0.1/24")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IPForward")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("ipv4")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IPMasquerade")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("yes")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("DHCPServer")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("yes")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[DHCPServer]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EmitDNS")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("yes")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("DNS")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("192.168.0.1")]),a._v("\n")])])]),t("p",[a._v("创建"),t("code",[a._v("20-lxc-dummy.netdev")]),a._v("文件，内容如下：")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[NetDev]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Name")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("lxc-dummy")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Kind")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("dummy")]),a._v("\n")])])]),t("p",[a._v("创建"),t("code",[a._v("20-lxc-dummy.network")]),a._v("文件，内容如下：")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Match]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Name")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("lxc-dummy")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Network]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Bridge")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("lxc-bridge")]),a._v("\n")])])]),t("p",[a._v("如此，名为 "),t("code",[a._v("lxc-bridge")]),a._v(" 的网桥如同路由器的 LAN 口，接入的设备可自动获取 IP 并上网。")]),a._v(" "),t("p",[a._v("注意，这里我们将 "),t("code",[a._v("192.168.0.1")]),a._v(" 作为了 DNS 服务器，但此时还没有架设它。一会儿将解决这个问题。")]),a._v(" "),t("p",[a._v("由于 LXC 容器要提供服务，端口转发是必备的，因此防火墙是必不可少的。")]),a._v(" "),t("h5",{attrs:{id:"安装-firewalld-防火墙"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装-firewalld-防火墙"}},[a._v("#")]),a._v(" 安装 firewalld 防火墙")]),a._v(" "),t("p",[a._v("Debian 10 已将 iptables 更换为 nftables。但我们并不手动配置这些 *tables，而是使用 firewalld 作为防火墙。firewalld 可以认为是 *tables 的前端。")]),a._v(" "),t("p",[a._v("注意，一旦安装了 firewalld，之前在 systemd-networkd 中设置的 NAT 转发会作废，而 DHCP 服务也会被阻断。一会儿将解决这些问题。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("apt")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("install")]),a._v(" firewalld\nsystemctl "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("enable")]),a._v(" firewalld\nsystemctl start firewalld\n")])])]),t("p",[a._v("缺省情况下，SSH 服务已被放行。")]),a._v(" "),t("h6",{attrs:{id:"将后端切换为-nftables"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#将后端切换为-nftables"}},[a._v("#")]),a._v(" 将后端切换为 nftables")]),a._v(" "),t("p",[a._v("依据发行版不同，firewalld 可能使用 iptables 或 nftables 做后端。推荐使用 nftables 做后端。")]),a._v(" "),t("p",[a._v("打开 "),t("code",[a._v("/etc/firewalld/firewalld.conf")]),a._v(" 文件，找到并设置以下选项。")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# FirewallBackend")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# Selects the firewall backend implementation.")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# Choices are:")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#\t- nftables (default)")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#\t- iptables (iptables, ip6tables, ebtables and ipset)")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("FirewallBackend")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("nftables")]),a._v("\n")])])]),t("p",[a._v("如果之前设置为了 iptables，将其改为 nftables。修改后，可能需要重启主机才能完全生效。")]),a._v(" "),t("p",[a._v("在 Debian 10 的软件包中，firewalld 依然依赖 iptables。不过，修改了配置文件并重启后，iptables 不做任何用途使用。"),t("code",[a._v("iptables -L")]),a._v(" 的输出结果应该是空。不需要管它。")]),a._v(" "),t("h6",{attrs:{id:"配置外网"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置外网"}},[a._v("#")]),a._v(" 配置外网")]),a._v(" "),t("p",[a._v("将外网接口 "),t("code",[a._v("ens192")]),a._v(" 接入 external 区域。此区域将作为 NAT 的出口，以及端口转发。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("firewall-cmd --zone"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("external --add-interface"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("ens192 --permanent\nfirewall-cmd --zone"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("external --add-service"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("ssh --permanent "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 这条应该默认存在，不过再写一次")]),a._v("\n\nfirewall-cmd --zone"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("external --add-masquerade --permanent\nfirewall-cmd --zone"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("external --add-forward-port"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("port"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("9002")]),a._v(":proto"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("tcp:toport"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("22")]),a._v(":toaddr"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("192.168")]),a._v(".0.2 --permanent\nfirewall-cmd --zone"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("external --add-forward-port"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("port"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("80")]),a._v(":proto"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("tcp:toport"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("80")]),a._v(":toaddr"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("192.168")]),a._v(".0.2 --permanent\nfirewall-cmd --zone"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("external --add-forward-port"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("port"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("443")]),a._v(":proto"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("tcp:toport"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("443")]),a._v(":toaddr"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("192.168")]),a._v(".0.2 --permanent\n\nfirewall-cmd --reload\n")])])]),t("p",[a._v("注意，因为 firewalld 服务已经开启，如果这里没有设置 "),t("code",[a._v("--add-masquerade")]),a._v("，systemd-networkd 中设置的 "),t("code",[a._v("IPMasquerade=yes")]),a._v(" 无效。另外，不要搞混在哪里设置 masquerade。对于 firewalld，在 NAT 的出口设置 masquerade；对于 systemd-networkd，在 NAT 的入口设置 masquerade。")]),a._v(" "),t("h6",{attrs:{id:"配置内网"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置内网"}},[a._v("#")]),a._v(" 配置内网")]),a._v(" "),t("p",[a._v("将内网 "),t("code",[a._v("lxc-bridge")]),a._v(" 接入 internal 区域。此区域将被配置为类似于路由器的 LAN。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("firewall-cmd --zone"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("internal --add-interface"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("lxc-bridge --permanent\nfirewall-cmd --zone"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("internal --add-service"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("dhcp --permanent\nfirewall-cmd --zone"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("internal --add-service"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("dns --permanent\n\nfirewall-cmd --reload\n")])])]),t("h6",{attrs:{id:"重要提示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重要提示"}},[a._v("#")]),a._v(" 重要提示")]),a._v(" "),t("p",[a._v("必须为 "),t("code",[a._v("lxc-bridge")]),a._v(" 分配到一个不同于 external 区域之外的区域，而绝不可以接入到 external 区域（因为我们在 external 区域上设置了 masquerade）。")]),a._v(" "),t("p",[a._v("如果主机上还有其他网卡，请根据网卡的角色手动为其指定一个区域。默认情况下，未指定区域的网卡将被接入 public 区域。作为外网使用的网卡应接入之前配置好的 external 区域。")]),a._v(" "),t("h5",{attrs:{id:"安装-dns-服务器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装-dns-服务器"}},[a._v("#")]),a._v(" 安装 DNS 服务器")]),a._v(" "),t("p",[a._v("这里的 DNS 服务器是为了缓存 DNS 解析结果，因此使用 dnsmasq。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("apt")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("install")]),a._v(" dnsmasq\n")])])]),t("p",[a._v("编辑 "),t("code",[a._v("/etc/dnsmasq.conf")]),a._v(" 文件，内容改为：")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[a._v("no-resolv\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("server")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("114.114.114.114")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("interface")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("lxc-bridge")]),a._v("\n")])])]),t("p",[a._v("如果希望使用 "),t("code",[a._v("/etc/resolv.conf")]),a._v(" 的 DNS 服务器设置，则文件内容只需要这一行：")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("interface")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("lxc-bridge")]),a._v("\n")])])]),t("p",[a._v("启动 dnsmasq 服务。注意，如果启动失败，使用 "),t("code",[a._v("ss -unlp")]),a._v(" 命令检查是否有其他程序占用了 UDP 53 端口。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("systemctl "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("enable")]),a._v(" dnsmasq\nsystemctl start dnsmasq\n")])])]),t("h4",{attrs:{id:"使用-lxc-3-0"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-lxc-3-0"}},[a._v("#")]),a._v(" 使用 LXC 3.0")]),a._v(" "),t("p",[a._v("Debian 9 搭配的是 LXC 2.0，而 Debian 10 搭配的是 LXC 3.0。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("apt")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("install")]),a._v(" lxc\n")])])]),t("h5",{attrs:{id:"创建一个名为-name-的容器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建一个名为-name-的容器"}},[a._v("#")]),a._v(" 创建一个名为 NAME 的容器")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("lxc-create -n NAME -t download -- --server mirrors.tuna.tsinghua.edu.cn/lxc-images --keyserver"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("hkp://keyserver.ubuntu.com:80\n")])])]),t("p",[a._v("2019 年 5 月注：这里使用了清华大学开源软件镜像站作为 lxc-images 的上游仓库。但是截至目前，清华大学开源软件镜像站的 lxc-images 存在严重的索引提前于内容同步完成的情况，因此如果报错 404，请将 "),t("code",[a._v("--server mirrors.tuna.tsinghua.edu.cn/lxc-images")]),a._v(" 部分删除，使用官方源。")]),a._v(" "),t("p",[a._v("2019 年 12 月注：截至目前，清华大学开源软件镜像站的 lxc-images 依然存在严重的索引提前于内容同步完成的情况。山东大学镜像站已提供 lxc-images 的"),t("RouterLink",{attrs:{to:"/guide/lxc-images.html"}},[a._v("可靠镜像")]),a._v("。可改为以下命令。")],1),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("lxc-create -n NAME -t download -- --server intranet.mirrors.oops-sdu.cn/lxc-images --no-validate\n")])])]),t("h5",{attrs:{id:"启停容器、进入容器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#启停容器、进入容器"}},[a._v("#")]),a._v(" 启停容器、进入容器")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("lxc-start -n NAME\nlxc-attach -n NAME\n")])])]),t("p",[a._v("注意，如果你使用的是 LXC 1.0，请将 "),t("code",[a._v("lxc-start -n NAME")]),a._v(" 改为 "),t("code",[a._v("lxc-start -n NAME -F")]),a._v("。")]),a._v(" "),t("p",[a._v("进入容器后，可以发现未分配网络。因此，按 Ctrl+D 退出容器，然后用以下命令建议容器退出。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("lxc-stop -n NAME\n")])])]),t("h5",{attrs:{id:"为容器分配网络、共享文件夹、自动启动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为容器分配网络、共享文件夹、自动启动"}},[a._v("#")]),a._v(" 为容器分配网络、共享文件夹、自动启动")]),a._v(" "),t("p",[a._v("编辑 "),t("code",[a._v("/var/lib/lxc/NAME/config")]),a._v(" 文件，最后两行应该像这样。（早期版本的 LXC 与此略有不同。）")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# Network configuration")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("lxc.net.0.type")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" empty")]),a._v("\n")])])]),t("p",[a._v("将其改为")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# Network configuration")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("lxc.net.0.type")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" veth")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("lxc.net.0.link")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" lxc-bridge")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("lxc.net.0.flags")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" up")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("lxc.net.0.hwaddr")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" 00:16:3e:xx:xx:xx")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# Autostart")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("lxc.start.auto")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" 1")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("lxc.start.delay")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" 0")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("lxc.start.order")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" 0")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# Mount")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("lxc.mount.entry")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" /path/to/folder1 path/to/folder2 none bind 0 0")]),a._v("\n")])])]),t("p",[a._v("即可实现相应的配置。")]),a._v(" "),t("p",[a._v("请注意挂载文件夹的写法。这将把主机的 "),t("code",[a._v("/path/to/folder1")]),a._v(" 文件夹与容器内的 "),t("code",[a._v("/path/to/folder2")]),a._v(" 文件夹联通。容器内该文件夹必须事先存在，否则会报错。换句话说，记得在主机事先创建好 "),t("code",[a._v("/var/lib/lxc/NAME/rootfs/path/to/folder2")]),a._v(" 文件夹。")]),a._v(" "),t("h5",{attrs:{id:"示例-容器内开启-ssh"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#示例-容器内开启-ssh"}},[a._v("#")]),a._v(" 示例：容器内开启 SSH")]),a._v(" "),t("p",[a._v("首先，尽管主机已经开启了 DHCP 服务，应当使用静态 IP 来配置容器，这样才能和之前在 firewalld 中配置好的端口转发规则一致。假设之前在主机内设置了 "),t("code",[a._v("firewall-cmd --zone=public --add-forward-port=port=9002:proto=tcp:toport=22:toaddr=192.168.0.2")]),a._v("，则将容器内的 IP 设置为 "),t("code",[a._v("192.168.0.2")])]),a._v(" "),t("p",[a._v("后，直接安装 SSH 服务器即可从主机的 9002 端口访问 SSH。同样，在容器内推荐使用 systemd-networkd 来配置网络。")]),a._v(" "),t("h4",{attrs:{id:"lxc-主机的其他配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lxc-主机的其他配置"}},[a._v("#")]),a._v(" LXC 主机的其他配置")]),a._v(" "),t("p",[a._v("以下配置与 LXC 方案无关，仅为推荐。")]),a._v(" "),t("h5",{attrs:{id:"安装-molly-guard"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装-molly-guard"}},[a._v("#")]),a._v(" 安装 molly-guard")]),a._v(" "),t("p",[a._v("此软件包可避免意外关闭或重启服务器。使用 "),t("code",[a._v("lxc-attach")]),a._v(" 在主机上操作容器时，以为在操作容器实际上却操作了主机是很常见的失误。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("apt")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("install")]),a._v(" molly-guard\n")])])]),t("p",[a._v("可顺便将主机名更改为有意义的名称，如 "),t("code",[a._v("lxc-host")]),a._v("。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("hostnamectl set-hostname lxc-host\n")])])]),t("h5",{attrs:{id:"安装-haveged"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装-haveged"}},[a._v("#")]),a._v(" 安装 haveged")]),a._v(" "),t("p",[a._v("虚拟机更容易出现熵不足的问题。比如，是否开机后 SSH 连接一直超时，然后从控制台登录后 SSH 连接又突然好了？这种情况很可能是熵不足。haveged 通过使用质量较低的伪随机数填充系统的熵池，达到加速 "),t("code",[a._v("/dev/random")]),a._v(" 的目的，从而避免熵不足的问题。仅当安全不是首要考虑因素时，才应使用该软件，否则应将硬件随机数发生器直通到虚拟机内部。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("apt")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("install")]),a._v(" haveged\nsystemctl "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("enable")]),a._v(" haveged\nsystemctl start haveged\n")])])]),t("p",[a._v("注意，提供随机数是内核的事情，因此只能在主机上做这个事情。")]),a._v(" "),t("h5",{attrs:{id:"创建-swap-文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建-swap-文件"}},[a._v("#")]),a._v(" 创建 SWAP 文件")]),a._v(" "),t("ol",[t("li",[a._v("假设 SWAP 文件的大小为 10 GiB。创建一个大小为 10GiB 的全零文件。")])]),a._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("dd")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("if")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("/dev/zero "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("of")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("/data/swapfile "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("bs")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("1M "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("count")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("10240")]),a._v("\n")])])]),t("p",[a._v("*对于 XFS 或 F2FS 文件系统，请确保创建全零文件，而不是使用 fallocate 或者 dd 等创建稀疏文件。不然可能无法 mkswap 和 swapon。见 "),t("a",{attrs:{href:"https://bugzilla.redhat.com/show_bug.cgi?id=1129205#c3",target:"_blank",rel:"noopener noreferrer"}},[a._v("Bug 1129205 - fallocate to create swap file creates a file with holes"),t("OutboundLink")],1),a._v("。")]),a._v(" "),t("p",[t("em",[a._v("如非必要，不要随便使用 dd 等命令生成空的大文件。尽可能产生稀疏文件以节约时间和保护 SSD 寿命。本处为不得已而为之。")])]),a._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[a._v("确保该文件的所有者和组均为 root。")])]),a._v(" "),t("li",[t("p",[a._v("将其权限置为 600。")])])]),a._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("chmod")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("600")]),a._v(" /data/swapfile\n")])])]),t("ol",{attrs:{start:"4"}},[t("li",[a._v("格式化并临时启用该交换文件。")])]),a._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("mkswap")]),a._v(" /data/swapfile "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&&")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("swapon")]),a._v(" /data/swapfile\n")])])]),t("ol",{attrs:{start:"5"}},[t("li",[a._v("确保 SWAP 生效。检查以下命令返回的结果中的 Swap 一行的值是否增加了。")])]),a._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("free")]),a._v(" -h\n")])])]),t("ol",{attrs:{start:"6"}},[t("li",[a._v("修改 /etc/fstab。在最后增加一行")])]),a._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[a._v("/data/swapfile none swap defaults "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\n")])])]),t("p",[t("em",[a._v("确保 /data 的挂载在该行之前出现。")])]),a._v(" "),t("ol",{attrs:{start:"7"}},[t("li",[a._v("重启系统，再用 free 命令查看 SWAP 是否生效。")])]),a._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[a._v("systemctl "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("reboot")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("free")]),a._v(" -h\n")])])]),t("h5",{attrs:{id:"加速-ssh-登录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加速-ssh-登录"}},[a._v("#")]),a._v(" 加速 SSH 登录")]),a._v(" "),t("p",[a._v("默认配置的 SSH 服务会对客户端 IP 做一些检查，如 DNS 反向解析、GSS 认证，非常耗时。建议关闭。\n打开 "),t("code",[a._v("/etc/ssh/sshd_config")]),a._v(" 文件，找到并设置以下选项。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("UseDNS no\nGSSAPIAuthentication no\n")])])]),t("p",[a._v("重启 SSH 服务。")]),a._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[a._v("systemctl restart sshd\n")])])]),t("h2",{attrs:{id:"镜像同步方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#镜像同步方案"}},[a._v("#")]),a._v(" 镜像同步方案")]),a._v(" "),t("h3",{attrs:{id:"工具选择"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工具选择"}},[a._v("#")]),a._v(" 工具选择")]),a._v(" "),t("p",[a._v("镜像站同步的内容大致分为两类：一类是完全同步的仓库，如 ArchLinux 源；一类是需要选择性同步的仓库，如 Debian、Ubuntu 源等，受镜像站容量限制，只同步 amd64 指令集的二进制程序。")]),a._v(" "),t("p",[a._v("对于前者，rsync 通常是最合适的选择。")]),a._v(" "),t("p",[a._v("对于后者，我们选择了 apt-mirror 工具，该工具提供了选择性同步功能，并实现了同步的原子性。")]),a._v(" "),t("h3",{attrs:{id:"原子性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原子性"}},[a._v("#")]),a._v(" 原子性")]),a._v(" "),t("p",[a._v("仓库由索引文件和资源文件组成，这些文件需要保持一致。")]),a._v(" "),t("p",[a._v("镜像站必须达到如下目标。")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("镜像站的状态")]),a._v(" "),t("th",[a._v("版本1")]),a._v(" "),t("th",[a._v("版本1升级到版本2")]),a._v(" "),t("th",[a._v("版本2")]),a._v(" "),t("th",[a._v("版本2升级到版本3")]),a._v(" "),t("th",[a._v("版本3")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("用户访问的内容")]),a._v(" "),t("td",[a._v("版本1")]),a._v(" "),t("td",[a._v("版本1")]),a._v(" "),t("td",[a._v("版本2")]),a._v(" "),t("td",[a._v("版本2")]),a._v(" "),t("td",[a._v("版本3")])])])]),a._v(" "),t("p",[a._v("即，进行同步时，镜像站需要保留新旧两个版本的内容，并在同步结束时，以非常快的速度完成版本切换。只有这样，才能保证用户使用时不会出错。想象一下，一本书，前一半页码是第1版第1次印刷的内容，后一半则变成了第1版第2次印刷的内容，这样的书显然是无法阅读的。")]),a._v(" "),t("p",[a._v("apt-mirror 工具已经做好了原子性的工作。")]),a._v(" "),t("p",[a._v("rsync 虽然也有 "),t("code",[a._v("--delay-updates")]),a._v(" "),t("code",[a._v("--delete-after")]),a._v(" 这样的选项，但从实际体验来看效果并不好，因此，我们姑且认为 rsync 不具备原子性，亲自完成保证原子性的工作。")]),a._v(" "),t("h3",{attrs:{id:"保证原子性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#保证原子性"}},[a._v("#")]),a._v(" 保证原子性")]),a._v(" "),t("h4",{attrs:{id:"引子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引子"}},[a._v("#")]),a._v(" 引子")]),a._v(" "),t("p",[a._v("在这之前，我们来探究一个小问题。")]),a._v(" "),t("p",[a._v("假设磁盘上存在一个文件 "),t("code",[a._v("/path/to/file")]),a._v("。")]),a._v(" "),t("p",[a._v("不考虑文件权限等问题，只从文件内容的角度来说，以下两种操作是否等价？")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" /path/to/file\n")])])]),t("p",[a._v("将空内容写入到该文件中。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("rm /path/to/file && touch /path/to/file\n")])])]),t("p",[a._v("删除该文件，并重建一个空文件。")]),a._v(" "),t("p",[a._v("看起来，"),t("code",[a._v("/path/to/file")]),a._v(" 的内容均被清空，似乎是等价的。然而，并不是这样。运行并观察下面的两段代码。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("echo")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"foo"')]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" /tmp/file1\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("ln")]),a._v(" -sf /tmp/file1 /tmp/file2\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" /tmp/file2\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("cat")]),a._v(" /tmp/file1\n")])])]),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("echo")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"foo"')]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" /tmp/file1\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("ln")]),a._v(" -sf /tmp/file1 /tmp/file2\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("rm")]),a._v(" /tmp/file2 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&&")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("touch")]),a._v(" /tmp/file2\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("cat")]),a._v(" /tmp/file1\n")])])]),t("p",[a._v("第一段代码，随着"),t("code",[a._v("file2")]),a._v(" 被清空，"),t("code",[a._v("file1")]),a._v("  也同时被清空了。")]),a._v(" "),t("p",[a._v("第二段代码，"),t("code",[a._v("file1")]),a._v(" 并没有被清空，因为在删除 "),t("code",[a._v("file2")]),a._v(" 这个文件时，它与 "),t("code",[a._v("file1")]),a._v(" 的关系被解除了。")]),a._v(" "),t("p",[a._v("PS: 为什么有那么多人认为“Linux 的软链接如同 Windows 的快捷方式”？谬论重复一千遍，也不能变为真理，但是还真有一群傻瓜认为这句话正确，原因仅仅是因为大家都这么说。真正正确的说法是，“Linux 的软链接如同 Windows 的软链接；Linux 的 .desktop 文件如同 Windows 的快捷方式”。")]),a._v(" "),t("h4",{attrs:{id:"冗余-似乎是必要的代价"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#冗余-似乎是必要的代价"}},[a._v("#")]),a._v(" 冗余，似乎是必要的代价？")]),a._v(" "),t("p",[a._v("原子性，可用以下流程表示。")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("第一步：通过魔法，提供一个目录A的副本，记为目录B。")])]),a._v(" "),t("li",[t("p",[a._v("第二步：用户或者程序改动目录B。")])]),a._v(" "),t("li",[t("p",[a._v("第三步：通过魔法，用目录B代替目录A。")])])]),a._v(" "),t("p",[a._v("通过以上的步骤，可以保证目录A始终保持一致性。如同显卡的双缓冲机制一样，下一个场景完全准备好了，才能替换上一个场景，以避免画面闪烁的情况，也就是不一致性。")]),a._v(" "),t("p",[a._v("那么，如何实现步骤中的魔法呢？")]),a._v(" "),t("p",[t("strong",[a._v("方法一：复制")])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("效率：低。浪费磁盘空间和复制的时间。")])]),a._v(" "),t("li",[t("p",[a._v("是否保证了原子性：是。")])]),a._v(" "),t("li",[t("p",[a._v("例子：git——用户可以对当前工作区的文件做任何修改，然后 commit 或者 revert。为了保证已经 commit 的数据不丢失，复制一份是必须的。")])])]),a._v(" "),t("p",[t("strong",[a._v("方法二：链接")])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("方法：链接。硬链接、软链接都行。")])]),a._v(" "),t("li",[t("p",[a._v("效率：高。没有浪费磁盘空间，不需要复制。")])]),a._v(" "),t("li",[t("p",[a._v("是否保证了原子性："),t("strong",[a._v("否")]),a._v("。")])]),a._v(" "),t("li",[t("p",[a._v("这是一个不可行的办法。原因很简单，对目录B内文件的操作可以反过来对目录A的文件造成影响。还记得刚才的引子吗？")])])]),a._v(" "),t("p",[a._v("你还能想到其他的方法吗？")]),a._v(" "),t("p",[a._v("很遗憾，如果没有其他魔法的支持，复制就是唯一的办法。")]),a._v(" "),t("h4",{attrs:{id:"cow-aka-写时复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cow-aka-写时复制"}},[a._v("#")]),a._v(" COW (aka. 写时复制)")]),a._v(" "),t("p",[a._v("btrfs 和 ZFS 文件系统都支持 COW。COW 的意思是，将文件A复制到文件B时，暂时不执行复制动作，而是让两个文件共用一份存储空间。当文件A或B发生改动时，执行复制动作，将两个文件分开。")]),a._v(" "),t("p",[a._v("COW 就是文件系统提供的“魔法”。很显然，COW 只能由文件系统提供支持。")]),a._v(" "),t("p",[a._v("cp 命令提供了 COW 的支持，使用 "),t("code",[a._v("--reflink")]),a._v(" 选项控制。例如：")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("cp")]),a._v(" --reflink"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("always /path/to/fileA /path/to/fileB\n")])])]),t("p",[a._v("强制使用 COW 进行复制。失败则报错。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("cp")]),a._v(" --reflink"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("auto /path/to/fileA /path/to/fileB\n")])])]),t("p",[a._v("首先尝试 COW 进行复制，失败则会 fallback 到普通复制。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("cp")]),a._v(" --reflink"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("never /path/to/fileA /path/to/fileB\n")])])]),t("p",[a._v("强制使用普通复制。")]),a._v(" "),t("p",[a._v("将 COW 与普通复制、链接相提并论并不合适，因为 COW 和普通复制的效果一样——产生了一个与母本毫无联系的副本。在用户的眼中，COW 和普通复制是等价的。当然，在系统管理员眼中，COW 节约了时间和空间。")]),a._v(" "),t("h4",{attrs:{id:"依赖-cow-的原子性脚本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖-cow-的原子性脚本"}},[a._v("#")]),a._v(" 依赖 COW 的原子性脚本")]),a._v(" "),t("p",[a._v("有了 COW，我们可以有效率地保证原子性了。参考如下的脚本。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token shebang important"}},[a._v("#!/usr/bin/env bash")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 要保证原子性的目录路径，实际上为软链接，在脚本执行前指向 ${DIR_CURRENT}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("DIR")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("/path/to/dir\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 当前版本的文件")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("DIR_CURRENT")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("/path/to/dir-current\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 临时目录，用来存储下一版本的文件")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("DIR_NEW")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("/path/to/dir-new\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 加锁，保证此脚本不会多次执行。此部分略去。")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 将 ${DIR_CURRENT} 复制到 ${DIR_NEW}。强制使用 COW。")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("cp")]),a._v(" --reflink"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("always "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${DIR_CURRENT}")]),a._v('"')]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${DIR_NEW}")]),a._v('"')]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 执行用户程序，对 ${DIR_NEW} 做任何事情。")]),a._v("\n/path/to/some/dirty/work/here "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${DIR_NEW}")]),a._v('"')]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 将软链接指向 ${DIR_NEW}，即切换到新版本。")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("ln")]),a._v(" -sf "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${DIR_NEW}")]),a._v('"')]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${DIR}")]),a._v('"')]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 用 ${DIR_NEW} 取代 ${DIR_CURRENT}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("rm")]),a._v(" -rf "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${DIR_CURRENT}")]),a._v('"')]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("cp")]),a._v(" --reflink"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("always "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${DIR_NEW}")]),a._v('"')]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${DIR_CURRENT}")]),a._v('"')]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 将软链接指向 ${DIR_CURRENT}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("ln")]),a._v(" -sf "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${DIR_CURRENT}")]),a._v('"')]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${DIR}")]),a._v('"')]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("rm")]),a._v(" -rf "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"'),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("${DIR_NEW}")]),a._v('"')]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 完成")]),a._v("\n")])])]),t("p",[a._v("在如上的脚本中，DIR 目录始终保持了原子性。目的达到了。")]),a._v(" "),t("h3",{attrs:{id:"systemd-的-service-和-timer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#systemd-的-service-和-timer"}},[a._v("#")]),a._v(" systemd 的 service 和 timer")]),a._v(" "),t("p",[a._v("镜像站需要定期执行同步任务。我们不使用老旧的 corntab，而是将同步任务作为 systemd 的服务，并配置合适的定时器来定期执行。举例如下。")]),a._v(" "),t("p",[t("code",[a._v("/etc/systemd/system/example-task.service")]),a._v(" 文件如下。")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Unit]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Description")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("Example Task")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("After")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("network.target")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Wants")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("network.target")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Service]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Type")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("simple")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ExecStart")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("/path/to/example/task")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Restart")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("no")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Install]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("WantedBy")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("multi-user.target")]),a._v("\n")])])]),t("p",[t("code",[a._v("/etc/systemd/system/example-task.timer")]),a._v("文件如下。")]),a._v(" "),t("div",{staticClass:"language-ini extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ini"}},[t("code",[t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Unit]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Description")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("Timer for Example Task")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Timer]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("OnCalendar")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("*-*-* 17:00:00 UTC")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Unit")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("example-task.service")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token selector"}},[a._v("[Install]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("WantedBy")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v("timers.target")]),a._v("\n")])])]),t("p",[a._v("如图所示的定时器会在协调世界时 17 点时启动对应的服务。如果该服务执行的太慢，以至于 24 小时后依然没有结束，那么定时器不会重复启动该服务的第二个实例。")]),a._v(" "),t("p",[a._v("PS: Linux 中的"),t("code",[a._v("格林尼治时间")]),a._v("指"),t("strong",[a._v("格林尼治这个地区的时区")]),a._v("，而不是零时区——别忘了，英国实行夏时制。因此，为了消除歧义，无论是与他人交谈时还是在计算机世界中，永远不使用 "),t("code",[a._v("格林尼治时间")]),a._v(" 一词，也不要将时区设置为 "),t("code",[a._v("Etc/Greenwich")]),a._v("。将服务器的时区设置为 "),t("code",[a._v("协调世界时")]),a._v(" 即 "),t("code",[a._v("Etc/Utc")]),a._v(" 是个好习惯。")]),a._v(" "),t("p",[a._v("不要忘了将定时器设置为开机自启，并启动之。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("systemctl daemon-reload\nsystemctl "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("enable")]),a._v(" example-task.timer\nsystemctl start example-task.timer\n")])])]),t("p",[a._v("更多的配置选项可参考 systemd 的文档，不再赘述。")])])}),[],!1,null,null,null);s.default=n.exports}}]);